#pragma rtGlobals=1		// Use modern global access method.// utilities.ipf// functions that do simple little tasks like string conversion, simple math, redimensioning, etc.// ******************// string utilities:// buildlistFunction/s buildlist (prefix, start, stop)	string prefix	variable start, stop		string returnstring = ""	variable i		for (i=start; i <= stop; i += 1)					returnstring += (prefix+num2str(i)+";")			endfor		return returnstringend// buildlist2Function/s buildlist2 (template, start, stop)	string template	variable start, stop		string returnstring = ""	variable i		for (i=start; i <= stop; i += 1)					returnstring += (replacestring("XX",template,num2str(i))+";")			endfor		return returnstringend//TimeToSeconds// this function converts a timeheader to a number of seconds// a timeheader is an 8-point integer wave which is the numerical ascii codes for a string of the form "hr:mn:ss"// (this is how micam01 stores the time of the recording)Function TimeToSeconds (timeheader)	WAVE timeheader		String timestring = IntWaveToString(timeheader)	printf, "time of day %s\r", timestring			Variable hours = str2num(timestring[0,1])	Variable minutes = str2num (timestring[3,4])	Variable seconds = str2num (timestring [6,7])	Variable totalseconds = 60*60*hours + 60*minutes + seconds	return totalseconds	end// intwave to string// this function takes an integer wave and prints it to a string based on ASCII codesFunction/S IntWavetoString (intwave)	Wave intwave	Variable i, numchars = numpnts(intwave)	String resultstring = ""			for (i=0; i< numchars; i += 1)			resultstring[i] = num2char(intwave[i])	endfor	return resultstringend// UpTo_// gets the part of a filename string that precedes the "_" or the "mv"// starts looking backwards from before the .xxxFunction/S GetExperimentID(wholename)	String wholename		string upto = ""	variable len = strlen(wholename), i,j		// scan for an underscore (start from length - 5 to avoid extension)	for (i = (len - 5); i >= 0 ; i -= 1)		if (!cmpstr(wholename[i], "_"))			upto = wholename[0,i-1]			break		endif	endfor		if (cmpstr(upto,""))		return upto	endif		// if we didn't find one, scan for an m (as in "mv")	upto = ""		for (j = (len - 5); j >= 0 ; j -= 1)		if (!cmpstr(wholename[j], "m"))			upto = wholename[0,j-1]			break		endif	endfor		if (cmpstr(upto,""))		return upto	endif		// if we didn't find one, scan FORWARDS for a -	upto = ""		for (j = 0; j <= (len-5) ; j += 1)		if (!cmpstr(wholename[j], "-"))			upto = wholename[0,j-1]			break		endif	endfor		if (cmpstr(upto,""))		return upto	endif			// if we make it here without returning anything, return null	return ""	end// like upto_ except returns part of the string preceding whateverFunction/s UpToWhatever (wholename,whatever[,searchfrontwards])	string wholename, whatever	variable searchfrontwards		variable startpoint	variable position	if (paramisdefault(searchfrontwards))		position = strsearch(wholename,whatever,0)			else		if (searchfrontwards)			position = strsearch(wholename,whatever,0)		else			position = strsearch(wholename,whatever,inf,3)		endif	endif		return wholename[0,position-1]end// like uptowhatever except returns part of the string after whateverFunction/s AfterWhatever (wholename,whatever[,searchfrontwards])	string wholename, whatever	variable searchfrontwards	variable startpoint	variable position	if (paramisdefault(searchfrontwards))		position = strsearch(wholename,whatever,0)			else		if (searchfrontwards)			position = strsearch(wholename,whatever,0)		else			position = strsearch(wholename,whatever,inf,3)		endif	endif		return wholename[position+strlen(whatever),strlen(wholename)-1]	end// returns the piece of a string between before and afterFunction/s BetweenBeforeAndAfter (wholename, before, after)	string wholename, before,after	wholename = afterwhatever(wholename, before)	wholename = uptowhatever(wholename, after)	return wholenameend// getxfromzname// looks at a string of the form blahblahblah##x##// gets the first numberFunction getxfromzname (wholename)	String wholename		string upto = ""	variable len = strlen(wholename), i,j, underscore, xposition		// scan backwards for an underscore 	for (i = (len - 1); i >= 0 ; i -= 1)		if (!cmpstr(wholename[i], "_"))						break		endif	endfor		// i is the position of the underscore	underscore = i		// scan backwards for an x 	for (i = (len - 1); i >= 0 ; i -= 1)		if (!cmpstr(wholename[i], "x"))						break		endif	endfor		// i is the position of the x	xposition = i		// number we want is everything between _ and x		return str2num(wholename[underscore+1,xposition-1])	end// getyfromzname// looks at a string of the form blahblahblah##x##// gets the first numberFunction getyfromzname (wholename)	String wholename		string upto = ""	variable len = strlen(wholename), i,j, underscore, xposition		// scan backwards for an x 	for (i = (len - 1); i >= 0 ; i -= 1)		if (!cmpstr(wholename[i], "x"))						break		endif	endfor		// i is the position of the x	xposition = i		// number we want is everything between x and the end	return str2num(wholename[xposition+1, len-1])	end// getmvnumber// return the number that follows "mv" in a stringFunction getmvnumber (thestring)	string thestring		variable strlength = strlen (thestring),i,numberstart,numberend		for (i =0; i < strlength; i += 1)			if (stringmatch(thestring[i,i+1],"mv"))			numberstart = i + 2			break		endif	endfor		// now start at i + 2 and go until we hit a letter or fall out of the loop	// numberend assigned to end of string so if we fall out that's what it will be	numberend = (strlength - 1)		for (i = numberstart; i < (strlength-1); i += 1)			// str2num returns Nan (numtype 2) if string char is not a number		if (numtype(str2num(thestring[i])) == 2)			numberend = (i - 1)			break		endif	endfor	//print thestring[numberstart,numberend]	return str2num(thestring[numberstart,numberend])	end	Function/s ListFromTextWave(textwave)	wave/t textwave		variable nstrings = numpnts(textwave),i	string list = ""		for (i=0; i < nstrings; i += 1)			list += (textwave[i] + ";")				endfor		//print list	return list		end// takes a semicolon-separated list and makes a textwave named 'name'// as of Igor 7 there is a built-in function ListToTextWave that does this.  should replace all instances of this with thatFunction listtotextwave_gc (list, name)	string list,name	make/O/T/n=(itemsinlist(list)) $name	WAVE/T thewave = $name	thewave = stringfromlist(p,list)end// returns a semicolon-separated list of the folders in datafolder// (not sure why I have to write this!!)Function/S listdatafolders (datafolder)	string datafolder	// list data folders	variable numdatafolders = CountObjects("", 4)	Variable i		String folderlist = ""	for (i = 0; i < numdatafolders; i += 1)		folderlist = addlistitem(getindexedobjname("",4,i),folderlist,";",i)	endfor		return folderlist	end// takes a comma-separated string containing ranges and singles and makes a wave containing//	the numbers//	Function parseliststring (liststring)	string liststring		// remove spaces	liststring = replacestring (" ",liststring,"")		variable liststringlength = strlen(liststring),i,commaposition	variable firstnumber, lastnumber, hyphenspot	string substring		// added /I flag 24mar09 - hopefully this doesn't break anything with file loading	make/I/O/n=0 numberlist		// find position of all commas	for (i=0; i < liststringlength; i += 1)		// find position of first comma		commaposition =strsearch(liststring, ",",i)						if (commaposition == -1)			commaposition = liststringlength		endif					//print i,commaposition						// OK, now the string we're working with is in between the commas		substring = liststring[i,commaposition-1]		//print substring				// substring is either a single number or a range		hyphenspot = strsearch(substring,"-",0) 		if (hyphenspot == -1)			// if no hyphen then it's a single number			//print str2num(substring)			redimension/n=(numpnts(numberlist)+1) numberlist			numberlist[numpnts(numberlist)-1] = str2num(substring)		else						firstnumber = str2num(substring[0,hyphenspot-1])			lastnumber = str2num(substring[hyphenspot+1, strlen(substring)-1])						do				//print firstnumber				redimension/n=(numpnts(numberlist)+1) numberlist				numberlist[numpnts(numberlist)-1] = firstnumber				firstnumber += 1							while (firstnumber <= lastnumber)				endif					if (commaposition == -1)			break		else			i = commaposition		endif					endfor	end// folderlist// should work identical to wavelistFunction/S folderlist (matchstring, separator, optionsstr)	string matchstring, separator, optionsstr	string result = ""	Variable numfolders  = CountObjects ("",4),i	for (i = 0; i < numfolders; i += 1)			if (stringmatch(getindexedObjName("", 4,i),matchstring))					//print (getindexedObjName("", 4,i) + separator)			result += (getindexedObjName("", 4,i) + separator)				endif			endfor	return resultend// returns the last howmany Chars of a string// useful for determining the extension of a filenameFunction/s LastNChars (somestring, howmany)	string somestring	variable howmany	variable length = strlen(somestring)		if (length < howmany)		printf "warning!  asked for last %d chars of a %d char string\r", howmany, strlen(somestring)		return somestring	endif	return somestring[length-(howmany),length-1]end//*****// CountFrames// counts the number of waves whose names begin with "frame"Function CountFrames()	String framelist = WaveList("frame*",";","")	Variable nframes = ItemsInList(framelist)	return nframes	end// num2threecharstring// very handy function that converts any 1,2,3-digit number to a padded 3-char stringFunction/S num2ThreeCharString (number)	Variable number		String test = num2str(number)	String returnvalue		Variable length = strlen(test)	if (length == 1)			returnvalue = ("00" + test)		elseif (length == 2)			returnvalue = ("0" + test)			elseif (length == 3)			returnvalue = test	endif		return returnvalueend// num2Ncharstring// very handy function that pads any number to an N-char string with zeroesFunction/S num2NCharString (number, N)	Variable number, N		String test = num2str(number)	String returnvalue		Variable i, length = strlen(test)	Variable charstoadd = N-length	if (charstoadd < 0)		print "string length error in num2NCharString"	endif	string padstring = ""			for (i=0; i < charstoadd; i += 1)		padstring += "0"		endfor		returnvalue = (padstring + test)	return returnvalueend// teststring has an integer on the end of it, and I want that integerFunction return_end_integer (teststring)	string teststring		variable length = strlen(teststring),i		// ASCII digits are 48-57 inclusive		for (i=(length-1); i >= 0 ; i -= 1)				if  ((char2num(teststring[i]) < 48) || (char2num(teststring[i]) > 57))			// character is not an integer			break		endif		endfor			return str2num(teststring[i+1, strlen(teststring)-1])		end// returns a ;-separated list of "change points" in the inputted text waveFunction/s textchanges (textwave)	WAVE/T textwave		string returnstring = ""	variable numelements = dimsize(textwave,0),i 	for (i=1; i < numelements; i += 1)			if (!stringmatch(textwave[i], textwave[i-1]))			returnstring += (num2str(i)+";")		endif	endfor		return returnstring	end// *****//// redimensioning utilities// truncate the longer wave so it has the same # of points as the shorter waveFunction equalizewavelengths(wave1,wave2)	WAVE wave1, wave2			variable wave1length = numpnts(wave1)	variable wave2length = numpnts(wave2)	variable reclengthdifference = abs(wave1length - wave2length)		if (wave1length > wave2length)		WAVE longer = wave1		WAVE shorter = wave2	else		WAVE longer = wave2		WAVE shorter = wave1	endif		deletepoints numpnts(shorter), reclengthdifference, longerend// creates global variables with the first three dimensions of movieFunction moviedims (movie)	Wave movie		Variable/G height = DimSize(movie,0)	Variable/G width = DimSize(movie,1)	Variable/G length = DimSize(movie,2)end// MatrixTo1D// takes a 3D wave as input and produces a 1D wave with the name "inputwavename_1d"// useful for determining the range of values used by the camera for a particular movieFunction MatrixTo1D(movie)	Wave movie		Variable height = Dimsize(movie,0)	Variable width = Dimsize(movie, 1)	Variable depth = DimSize (movie, 2)	String moviename = NameOfWave (movie)	String newname = moviename + "_1d"	Variable framesize = height*width			Make/O/N=(width*height*depth) $newname	WAVE onedmovie = $newname		onedmovie[] = movie[floor((p - framesize*floor(p/framesize))/width)][mod(p,width)][floor(p/framesize)]end// does the same thing along the long dimensionFunction MatrixTo1Drows_old(movie)	Wave movie		Variable width = Dimsize(movie,0)	Variable height = Dimsize(movie, 1)	Variable depth = DimSize (movie, 2)	String moviename = NameOfWave (movie)	String newname = moviename + "_rows1d"			Make/O/N=(width*height*depth) $newname	WAVE onedmovie = $newname		onedmovie[] = movie[mod(p,height)][floor((p - height*width*floor(p/(height*width)))/height)][floor(p/(height*width))]end// does the same thing along the long dimensionFunction MatrixTo1Drows(movie)	Wave movie		Variable height = Dimsize(movie,0)	Variable width = Dimsize(movie, 1)	Variable depth = DimSize (movie, 2)	String moviename = NameOfWave (movie)	String newname = moviename + "_rows1d"			Make/O/N=(width*height*depth) $newname	WAVE onedmovie = $newname		onedmovie[] = movie[mod(p,height)][floor(mod(p,height*width)/height)][floor(p/(height*width))]endFunction test3d ()		variable height = 61	variable width = 64	variable depth = 48, i,j,k		variable totalsize = height*width*depth		for (i=0; i < totalsize; i += 1)			printf "height=%d	width=%d		length=%d\r", mod(i,height), floor(mod(i,height*width)/height), floor(i/(height*width))	endforend// onedtomovie// does the opposite of Matrixto1dFunction OnedToMovie (line)	Wave line			String name = nameofwave(line)	String newname = name + "_recon"			variable length = numpnts (line)	variable depthofmovie = length/6144		make/o/n=(96,64, depthofmovie) $newname	WAVE recon = $newname		//p will range from 0 to 95	//q will range from 0 to 63			recon[][][] = line[r*6144 + p*64 + q]end// MatrixToFrames// takes a 3D matrix name and creates a 2D wave for each frame of it// NB: overwrites existing "frame" waves// this is useful for preparing to dump to a quicktime movie after processing, averaging, etc.Function MatrixToFrames (movie)	Wave movie		String moviename = NameOfWave(movie)	Variable height = Dimsize(movie,0)	Variable width = Dimsize(movie,1)	Variable nframes = DimSize(movie,2)	Variable i		String framename		for (i = 0; i < nframes; i+= 1)				framename = "frame" + num2str(i)		Make/O/N=(height,width) $framename		WAVE newframe = $framename				newframe[][] = movie[p][q][i]			endforendFunction FrameToLineCols (framename)	String framename		WAVE frame = $framename			Variable height = DimSize(frame,0)	variable width = DimSize(frame,1)	String linename = framename + "_1d"	variable i,j, nextspot = 0		Make/O/N=(height*width) $linename		wave line = $linename		for (i=0;i < height; i+=1)			for (j=0;j<width;j+=1)					line[nextspot] = frame[i][j]			nextspot+=1					endfor	endforendFunction FrameToLineRows (framename)	String framename		WAVE frame = $framename			Variable height = DimSize(frame,0)	variable width = DimSize(frame,1)	String linename = framename + "_1d"	variable i,j, nextspot = 0		Make/O/N=(height*width) $linename		wave line = $linename		for (i=0;i < width; i+=1)			for (j=0;j<height;j+=1)					line[nextspot] = frame[j][i]			nextspot+=1					endfor	endforend// simple math utilitiesFunction averageme (testwave, testvalue, datawave)	WAVE testwave, datawave	variable testvalue		duplicate/o datawave tempdatawave	tempdatawave = ((testwave[p] < testvalue + 0.001) && (testwave[p] > testvalue - 0.001)) ? tempdatawave[p] : NaN	removeNans(tempdatawave)		Wavestats/q tempdatawave	killwaves tempdatawave	return V_avg	endFunction SDme (testwave, testvalue, datawave)	WAVE testwave, datawave	variable testvalue		duplicate/o datawave tempdatawave	tempdatawave = ((testwave[p] < testvalue + 0.001) && (testwave[p] > testvalue - 0.001)) ? tempdatawave[p] : NaN	removeNans(tempdatawave)		Wavestats/q tempdatawave	killwaves tempdatawave	return V_sdev	endFunction binary2int (binarystring, signed)	string binarystring	variable signed		string nextdigit	variable numchars = strlen(binarystring),i	variable result = 0		if ((signed == 0) || ((signed == 1) && (!cmpstr(binarystring[0], "0"))))		for (i=(numchars-1); i >= 0; i -= 1)				nextdigit = binarystring[i]			result += str2num(nextdigit)*2^(numchars-1-i)			endfor	elseif ((signed == 1) && (!cmpstr(binarystring[0], "1")))				// convert to two's complement		binarystring = twoscomplement(binarystring)		// then proceed as if unsigned		result = binary2int(binarystring,0)				// but make the result negative		result *= -1			endif		return resultend// courtesy wikipedia:// A shortcut to manually convert a binary number into its two's complement is to start at the least significant bit (LSB)// and copy all the zeros (working from LSB toward the most significant bit) until the first 1 is reached; then copy that 1,// and flip all the remaining bits. Function/s twoscomplement (binarystring)	string binarystring		string resultstring = ""	variable numchars = strlen(binarystring),i		// find first 1	variable oneflag = 0	for (i=(numchars-1); i >= 0; i -= 1)		string nextchar = binarystring[i]		// if it's a zero, copy it		if (!oneflag)			if (!cmpstr(nextchar,"0"))				resultstring = nextchar + resultstring			else				resultstring = nextchar + resultstring				oneflag = 1			endif			else			resultstring =  SelectString(stringmatch(nextchar,"0"),("0" + resultstring) ,("1" + resultstring))		endif	endfor		return (resultstring)	end//**********Function CeilPwr2(x)	variable x		return 2^(ceil(log(x)/log(2)))end// divides a 1d wave by its peak and returns the name of the new waveFunction/S normtrace(trace)	WAVE trace		WaveStats/Q trace	duplicate/o trace $(Nameofwave(trace)+"norm")	WAVE tracenorm = $(Nameofwave(trace)+"norm")	 	tracenorm /= V_min		return nameofwave(tracenorm)end// divides a 1d wave by its firstpoint and returns the name of the new waveFunction/S normtrace_firstpoint(trace)	WAVE trace		duplicate/o trace $(Nameofwave(trace)+"norm")	WAVE tracenorm = $(Nameofwave(trace)+"norm")	 	tracenorm /= trace[0]		return nameofwave(tracenorm)end// divides a 1d wave by the average from start to stop and returns the name of the new waveFunction/S normtracebyrange (trace, pointstart, pointstop, suffix)	WAVE trace	variable pointstart, pointstop	string suffix		duplicate/o trace $(Nameofwave(trace)+suffix)	WAVE tracenorm = $(Nameofwave(trace)+suffix)	 	variable baselinevalue = mean(trace,pnt2x(trace,pointstart),pnt2x(trace,pointstop))	tracenorm /= baselinevalue		return nameofwave(tracenorm)end// takes the image on the top graph and divides it by its min value to make a new image called name + "pct"Function percent ()	WAVE frameimage = $(StringFromList(1,ImageNameList("",";")))	imagestats frameimage	String imagename = NameOfWave(frameimage)	print imagename	print V_min		make/O/n=(96,64) $(imagename + "pct")	WAVE percent = $(imagename + "pct")	duplicate/o frameimage percent	WAVE colors	duplicate/O colors percentcolors	Setscale/i x,0,1,percentcolors	percent /= V_min	newimage referencefordivision	AppendImage percent	modifyimage $(imagename + "pct") cindex = percentcolors	ColorScale/C/N=text0/F=0/A=MC cindex=percentcolors	end// function to multiply each frame of a movie pixel-by-pixel by an input frameFunction framemultiply(frame, movie)	Wave frame, movie		variable/g gotstats	if (!gotstats)		moviedims(movie)	endif		NVAR height, width, length	Variable i,j,k		for (k =0; k < length; k+= 1)		movie[][][k] = movie[p][q][k] * frame[p][q]	endfor	end// function to divide each frame of a movie pixel-by-pixel by an input frameFunction framedivide (movie, reference)	Wave movie, reference		Variable depth = DimSize(movie,2)	Variable index,i,j,k	Variable next = 0	String name	// strip off each frame into a dummy frame, divide it, and put it back	for (i = 1; i < depth; i += 1)				Make/O/N=(96,64) dummy		WAVE dummy		dummy[][] = movie[p][q][i]		dummy /= reference				movie[][][i] = dummy[p][q]				endfor		Beep;Beep;BeepEnd// moviemax// finds highest value in movieFunction moviemax (movie)	Wave movie		variable i,j,k,max = 0	Variable width = Dimsize(movie,0)	Variable height = Dimsize(movie, 1)	Variable depth = DimSize (movie, 2)	for (i = 3; i <= depth; i += 1)		for (j=0; j <=width; j += 1)					for (k=0; k <= height; k+= 1)								if (movie[j][k][i] > max)										max = movie[j][k][i]									endif							endfor					endfor				endfor		print max			return max	end// moviemin// finds lowest value in movieFunction moviemin (movie)	Wave movie		variable i,j,k,min = 0	Variable width = Dimsize(movie,0)	Variable height = Dimsize(movie, 1)	Variable depth = DimSize (movie, 2)	for (i = 3; i <= depth; i += 1)			for (j=0; j <=width; j += 1)					for (k=0; k <= height; k+= 1)								if (movie[j][k][i] < min)										min = movie[j][k][i]									endif							endfor					endfor				endfor		print min			return min	end// finds the minimum value in a movie and store its value an xyz location and the value in a 4-pt wave called minimumFunction FindMin ()	String moviename	Prompt moviename, "3D matrix containing movie", popup, WaveList("*v*",";","")		DoPrompt "enter info", moviename	if (V_flag)		abort	endif	WAVE movie = $moviename	Variable width = Dimsize(movie, 0)	Variable height = Dimsize(movie, 1)	Variable depth = Dimsize(movie,2)	Variable myflag = 0,j,k,i,numavg	String zlinename	NVAR timeresolution	Variable minxcoord,minycoord, mintime				// go through the ROI in each frame and find the minimum value in the movie		Variable minvalue = 5				// random value that will definitely not be the minimum		for (i=4; i < depth; i += 1)			for (j=0; j < width; j += 1)				for (k=0; k < height; k += 1)										if (movie[j][k][i] < minvalue)												minvalue = movie[j][k][i]						minxcoord = j						minycoord = k						mintime = (i-1)*timeresolution						//printf "new minvalue %g at %d,%d,%d ms\r", minvalue, minxcoord,minycoord,mintime											endif			endfor		endfor	endfor		printf "found minimum within polygon: %g at %d, %d, %d ms\r", minvalue, minxcoord,minycoord, mintime	Make/O/N=4 minimum	minimum[0] = minvalue	minimum[1] = minxcoord	minimum[2] = minycoord	minimum[3] = mintime	end// finds the minimum value of a 3d wave in a specified x-y polygon// assumes polygons in the ProgFront layerFunction FindMinInPoly ()	String moviename	Prompt moviename, "3D matrix containing movie", popup, WaveList("*v*",";","")		DoPrompt "enter info", moviename	if (V_flag)		abort	endif	WAVE movie = $moviename	Variable width = Dimsize(movie, 0)	Variable height = Dimsize(movie, 1)	Variable depth = Dimsize(movie,2)	Variable myflag = 0,j,k,i,numavg	String zlinename	NVAR timeresolution	Variable minxcoord,minycoord, mintime		Variable numofzs = ItemsInList(WaveList("polyavg*",";",""))		ImageGenerateROIMask $moviename	WAVE ROI = M_ROIMask			// go through the ROI in each frame and find the minimum value in the movie		Variable minvalue = 5				// random value that will definitely not be the minimum		for (i=4; i < depth; i += 1)			for (j=0; j < width; j += 1)				for (k=0; k < height; k += 1)						if (ROI[j][k])									if (movie[j][k][i] < minvalue)												minvalue = movie[j][k][i]						minxcoord = j						minycoord = k						mintime = (i-1)*timeresolution						//printf "new minvalue %g at %d,%d,%d ms\r", minvalue, minxcoord,minycoord,mintime											endif													endif			endfor		endfor	endfor		printf "found minimum within polygon for %s: %g at %d, %d, %d ms\r", moviename,minvalue, minxcoord,minycoord, mintime	printf "half-min = %g\r", minvalue/2 	Make/O/N=4 minimum	minimum[0] = minvalue	minimum[1] = minxcoord	minimum[2] = minycoord	minimum[3] = mintime	end// finds the maximum value of a 3d wave in a specified x-y polygon// assumes polygons in the ProgFront layerFunction FindMaxInPoly ()	String moviename	Prompt moviename, "3D matrix containing movie", popup, WaveList("*v*",";","")		DoPrompt "enter info", moviename	if (V_flag)		abort	endif	WAVE movie = $moviename	Variable width = Dimsize(movie, 0)	Variable height = Dimsize(movie, 1)	Variable depth = Dimsize(movie,2)	Variable myflag = 0,j,k,i,numavg	String zlinename	NVAR timeresolution	Variable maxxcoord,maxycoord, maxtime		Variable numofzs = ItemsInList(WaveList("polyavg*",";",""))		ImageGenerateROIMask $moviename	WAVE ROI = M_ROIMask			// go through the ROI in each frame and find the minimum value in the movie		Variable maxvalue = -1000000				// random value that will definitely not be the maximum		for (i=4; i < depth; i += 1)			for (j=0; j < width; j += 1)				for (k=0; k < height; k += 1)						if (ROI[j][k])									if (movie[j][k][i] > maxvalue)												maxvalue = movie[j][k][i]						maxxcoord = j						maxycoord = k						maxtime = (i-1)*timeresolution						//printf "new maxvalue %g at %d,%d,%d ms\r", maxvalue, maxxcoord,maxycoord,maxtime											endif													endif			endfor		endfor	endfor		printf "found maximum within polygon for %s: %g at %d, %d, %d ms\r", moviename,maxvalue, maxxcoord,maxycoord, maxtime	printf "half-max = %g\r", maxvalue/2 	Make/O/N=4 maximum	maximum[0] = maxvalue	maximum[1] = maxxcoord	maximum[2] = maxycoord	maximum[3] = maxtime	end// testpixel// tests whether value is within the range designated by high and lowFunction testpixel (value,high,low)	Variable value, high, low	if ((value < high) && (value > low))		return 1	else			return 0		endif	end// this function returns how many pixels in image are below valueFunction pixelsatms (image, value)	Wave image	Variable value	NVAR timeresolution		Variable height = dimsize(image,0)	variable width = dimsize(image,1)		Variable j,k,count = 0	for (j=0 ; j < height; j += 1)		for (k=0; k < width; k += 1)			if (image[j][k] <= value)				count += 1			endif		endfor	endfor	printf "%d pixels in %s equal to %f\r", count, Nameofwave(image),value	printf "this is area of %f mm-sq for Micam01 at 4x mag\r", count*.000529	return countend	// computes geometric distance between two ordered pairsFunction geodistance (x1,y1,x2,y2)	Variable x1,y1,x2,y2		return sqrt((y2-y1)^2 + (x2 - x1)^2)end// offset utilities// offsetgene// an offset function that doesn't require you to know how many waves there are//	also automatically changes axis to manual instead of automaticFunction offsetgene ([xoffset,yoffset])	Variable xoffset, yoffset	if (ParamIsDefault(xoffset))		Prompt xoffset, "x"		Prompt yoffset, "y"		DoPrompt "enter offsets", xoffset, yoffset	endif	String traces = TraceNameList ("",";",1)	String tracename	Variable ntraces = ItemsInList(traces)	Variable i	for (i=0; i < ntraces; i+= 1)			tracename = StringFromList  (i, traces)				ModifyGraph offset($tracename)={xoffset*i,yoffset*i}			endfor		setaxis/a left	doupdate	axismanual ("left")end// offset2// this time, it's personal// this offset function preserves the vertical order of the traces// this is for when you've set the order manually by dragging but you want to even out the spacingFunction offset2 ([xoffset,yoffset])	Variable xoffset, yoffset	if (ParamIsDefault(xoffset))		Prompt xoffset, "x"		Prompt yoffset, "y"		DoPrompt "enter offsets", xoffset, yoffset	endif	String traces = TraceNameList ("",";",1)	String tracename	Variable ntraces = ItemsInList(traces)	Variable i, oldyoffset		make/O/n=(ntraces) offsets	make/O/t/n=(ntraces) tracesbyoffset		// step through trace name list and generate two waves,	// one with the trace names and one with the offsets, as they are	for (i=0; i < ntraces; i+= 1)			tracename = StringFromList  (i, traces)				tracesbyoffset[i] = tracename		offsets[i] = YOffsetofWave($tracename,0)		//print tracename,offsets[i]	endfor		// sort the wave name list by the offset list	Sort offsets, tracesbyoffset	// turn the sorted text wave into the new traces list	string sortedtraceslist = listfromtextwave(tracesbyoffset)//	print sortedtraceslist	// do the same stuff as offset1	for (i=0; i < ntraces; i+= 1)			tracename = StringFromList  (i, sortedtraceslist)				ModifyGraph offset($tracename)={xoffset*i,yoffset*i}			endfor	//	killwaves offsets, tracesbyoffset		setaxis/a left	doupdate	axismanual ("left")end// scalexoffset// scales the x offsets of all traces in top graph by factorFunction scalexoffset (factor)	Variable factor	String traces = TraceNameList ("",";",1)	String tracename	Variable ntraces = ItemsInList(traces)	Variable i,oldyoffset,oldxoffset,newyoffset, newxoffset	for (i=0; i < ntraces; i+= 1)			tracename = StringFromList  (i, traces)		oldyoffset = YOffsetofWave($tracename,0)		oldxoffset = XOffsetofWave($tracename,0)		newxoffset = oldxoffset*factor		ModifyGraph offset($tracename)={newxoffset,oldyoffset}		//print oldoffset	endforend// scaleyoffset// scales the y offsets of all traces in top graph by the factor inputFunction scaleyoffset (factor)	Variable factor	String traces = TraceNameList ("",";",1)	String tracename	Variable ntraces = ItemsInList(traces)	Variable i,oldyoffset,oldxoffset,newyoffset	for (i=0; i < ntraces; i+= 1)			tracename = StringFromList  (i, traces)		oldyoffset = YOffsetofWave($tracename,0)		oldxoffset = XOffsetofWave($tracename,0)		newyoffset = oldyoffset*factor		ModifyGraph offset($tracename)={oldxoffset,newyoffset}		//print oldoffset	endforend// works on the top graph// when you like the offsets you've got but you want a better order// doesn't do anything to XOffsets for nowFunction ReorderOffsets (neworder)	WAVE neworder	string graphname = ""		String traces = TraceNameList(graphname, ";", 1 ), tracename	Variable ntraces = ItemsInList(traces),i	make/O/n=(ntraces) YOffsets, XOffsets	// first get all offsets	for (i=0; i < ntraces; i+= 1)			tracename = StringFromList  (i, traces)		YOffsets[i] = YOffsetofWave($tracename,0)		XOffsets[i] = XOffsetofWave($tracename,0)	endfor			// now reapply all offsets	for (i=0; i < ntraces; i+= 1)			tracename = StringFromList  (i, traces)		ModifyGraph offset($tracename)={XOffsets[i], YOffsets[neworder[i]]}	endfor		killwaves YOffsets, XOffsetsend// more complicated math utilitiesFunction simplefilter (filtreename)	String filtreename		WAVE filtree = $filtreename		Redimension/S filtree	// prepare for fft	FFT filtree	Duplicate/O filtree hiPass	WAVE/C high = hiPass		high=high*cmplx(1-1/(1+(p-20)^2/2000),0)	IFFT high	end// two recursive filters : very fast, very short// BUT non-linear !!  [ phase may not be preserved ]Function Lo_Pass(y,nuc) // nuc is the cut-off frequency        wave y                                  // use scaling (SetScale)        variable/D nuc        variable/D z=y[0],p=0,m=numpnts(y), nus=1/deltax(y)        variable/D a=exp(-2*Pi*nuc/nus), b=1-a, g        do                g=y[p]                z=a*z+b*g                y[p]=z                p+=1        while (p<m)endFunction Hi_Pass(y,nuc) // nuc is the cut-off frequency        wave y                                  // use scaling (SetScale)        variable/D nuc        variable/D z=y[0],p=0,m=numpnts(y), nus=1/deltax(y)        variable/D a=exp(-2*Pi*nuc/nus), b=1-a, g        do                g=y[p]                z=a*z+b*g                y[p]=g-z                p+=1        while (p<m)end//also handy// checks for existence of a global variable called variablename.// if it exists and is Nan, prompts for a new value.// if it doesn't exist, creates it and prompts for a value.Function askforglobal (variablename)	String variablename	variable value	string promptstring		if (Exists(variablename))		NVAR var = $variablename		if (numtype(var) == 2)						promptstring = "what is value of " + variablename			Prompt value, promptstring			DoPrompt "enter info", value			NVAR thevariable = $variablename			thevariable = value			return value		endif						else			promptstring = "what is value of " + variablename		Prompt value, promptstring		DoPrompt "enter info", value		variable/g $variablename		NVAR thevariable = $variablename		thevariable = value		return value				endifendFunction wait (howlong)	Variable howlong			howlong *= 100000		variable i,dummy	for (i = 0; i < howlong; i += 1)		dummy = sqrt(howlong) + howlong^2	endforend	Function cleanuploadedlist ()	SVAR list = root:loadedmovielist		Variable nitems = itemsinlist(list),i	String nextitem	variable removecount = 0		setdatafolder root:	for (i=0 ; i <= nitems; i += 1)		nextitem = stringfromlist(i,list)		//print nextitem		if (!DataFolderExists(nextitem))			//printf "%s does not exist\r",nextitem			list = removelistitem(i,list)			removecount += 1			i -= 1		endif		endfor		sortloadedlist()		// now that list is sorted, duplicates are easy to find		nitems = itemsinlist(list)	for (i=1; i <= nitems; i += 1)		if (stringmatch(stringfromlist(i,list),stringfromlist(i-1,list)))			list = removelistitem(i,list)			removecount += 1			 //i -= 1		endif	endfor		printf "removed %d items\r%d remaining\r", removecount, itemsinlist(list)	end// sorts loaded list by numberFunction sortloadedlist ()	SVAR list = root:loadedmovielist		list = sortlist(list,"",16)endfunction killnoprocs(from,to)	variable from,to		variable i	string name	for (i=from;i <= to; i += 1)			setdatafolder $("root:mv" + num2str(i))		name = getdatafolder(0)+"noproc"		killwaves $name			endfor	endFunction switchvalues (theWave, indexone, indextwo)	WAVE theWave	variable indexone, indextwo		variable temp = thewave[indexone]	thewave[indexone] = thewave[indextwo]	thewave[indextwo] = temp		endFunction tracefolder ()	setdatafolder root:	if (DataFolderExists("traces"))		setdatafolder traces	endif	endFunction rootfolder ()	setdatafolder root:	endFunction copywithsuffix (thewave, suffix)	wave thewave	string suffix		duplicate/o thewave $(nameofwave(thewave) + suffix)endFunction renamewithsuffix (thewave, suffix)	wave thewave	string suffix		rename thewave $(nameofwave(thewave) + suffix)endFunction renamewithprefix (thewave, prefix)	wave thewave	string prefix		rename thewave $(prefix + nameofwave(thewave))endFunction nanscan (thewave)	wave thewave		variable length = numpnts(thewave),i			for (i=0; i < length; i += 1)			if (numtype(thewave[i]) == 2)			printf "replaced point %d with a neighbor\r",i			if (i == 0)				thewave[i] = thewave[i+1]			else				thewave[i] = thewave[i-1]			endif		endif	endforendFunction replacestringinallnames (matchstring, replacewith)	string matchstring, replacewith	string list = wavelist("*"+matchstring+"*",";","")	variable nwaves = itemsinlist(list)	string oldname,newname	variable lengthofmatchstring,startposition,i		for (i=0; i < nwaves; i += 1)		oldname = stringfromlist(i,list)		WAVE thewave = $oldname			lengthofmatchstring = strlen(matchstring)		startposition = strsearch(oldname, matchstring,0)			if (startposition >= 0)			newname = replacestring(matchstring,oldname, replacewith)				rename thewave, $newname		endif	endfor			endFunction/S replacestringinname (thewave, matchstring, replacewith)	wave thewave	string matchstring, replacewith		string oldname = Nameofwave(thewave),newname		variable lengthofmatchstring = strlen(matchstring)	variable startposition = strsearch(oldname, matchstring,0)		if (startposition >= 0)		newname = replacestring(matchstring, oldname,replacewith)			rename thewave, $newname		return newname	endif		return oldname			end// firstmovieongraph// returns the name of the first image on a graph which corresponds to a 3D matrix in the current data folder// useful for picking out the movie from the reference imageFunction/s firstmovieongraph ()	Variable i, found = 0	String images = imagenamelist("",";"), moviename	for (i=0; i < itemsinlist(images);i+=1)				wave nextimage = $(stringfromlist(i,images))		moviename = stringfromlist(i,images)				if (dimsize(nextimage,2) > 1)			found = 1			break		endif			endfor		if (found)		return moviename	else		return ""	endif	end// last image on graph// returns the name of the last image on a graph// for VSD will skip the reference and get image1// for 2p will get image0Function/s lastimageongraph()	Variable i, found = 0	String images = imagenamelist("",";")		return stringfromlist(itemsinlist(images)-1, images)end// returns the index of the point in the wave which is closest to numberFunction whichelement (number,thewave)	variable number	WAVE thewave		duplicate thewave dummywave	dummywave -= number	dummywave = abs(dummywave)	wavestats/q dummywave		killwaves dummywave	return V_minloc	endFunction deleteNans (theWave)	WAVE theWave		variable length = numpnts(theWave),i		for (i=0; i < length; i += 1)			if (numtype(thewave[i]) == 2)			deletepoints i,1,thewave			i -= 1		endif		endfor	end// converts a 2 point wave (taken to be a cartesian coordinate pair)//  into a 2 point wave which can be plotted as a scatterFunction orderedpairconvertor (thewave)	WAVE thewave			variable xvalue = thewave[0]	variable yvalue = thewave[1]			thewave[0] = 0	setscale/i x, 0,xvalue,thewaveend//**************// Returns amount of free memory available to Igor.Function FreeMem()	string str	variable free, ind		str = GetStrFromList(IgorInfo(0),2,";")	ind = 1 + strsearch(str, ":", 0)	free = str2num(str[ind, strlen(str) - 1])	return freeEnd// sets every xth trace beginning with start to the color specified by red, green, blueFunction everyxth (x, start, red,green,blue)	variable x, start, red, green, blue		string traces = TraceNameList ("",";",1), nexttracename	variable ntraces = itemsinlist(traces),i		for (i=0; i < ntraces; i += 1)			nexttracename = (stringfromlist(i,traces))				if (!mod(i-start,x))			modifygraph rgb($nexttracename)=(red,green,blue)		endif	endfor		end// incrementsuffixnumber// adds one to a number at the end of a string and returns a new string// e.g. takes "mywave125" and returns "mywave126"// right now assumes three-digit numberFunction/s IncrementSuffixNumber (oldstring)	string oldstring		string newstring	variable length = strlen(oldstring)	string number = oldstring[length-3,length-1]	//print number		string newnumber = num2str(str2num(number)+1)		newstring = oldstring		newstring[length-3,length-1] = newnumber		newstring += "xxx"	return newstringendFunction renamewithincrementedsuffix (thewave)	WAVE thewave		string oldname = nameofwave(thewave)	string newname = incrementsuffixnumber(oldname)		rename thewave $newname	end// deletes points in targetwave if they are equal to any point in listwaveFunction DeleteValuesInlistwave (listwave, targetwave)	WAVE listwave, targetwave		variable listwavelength = numpnts(listwave)	variable targetwavelength = numpnts(targetwave)			variable i,j	for (i=0; i < listwavelength; i += 1)			findvalue/I=(listwave[i]) targetwave					if (V_value != -1)				deletepoints V_value,1,targetwave			//print targetwave[v_Value]				endif				endforendFunction SubtractBlank ()	variable i	for (i=240; i <= 485; i += 1)		WAVE trial = $("root:mv" + num2str(i) + ":mv" + num2str(i))		WAVE blank = $("root:mv486:mv486")		trial -= blank		trial *= -1	endforend// rebin to reduce the number of points in inputwave by reductionfactor (throw out remainder)// each point in the new wave becomes the sum of it and the following reductionfactor points in the inputwaveFunction rebin (inputwave, reductionfactor)	WAVE inputwave	variable reductionfactor	variable length = numpnts(inputwave),i,j		variable xoffset = dimoffset(inputwave,0)	variable xdelta = dimdelta(inputwave,0)		// the new wave will have this length (divide old number of points by reduction factor)	variable newnpnts = floor(length/reductionfactor)		make/D/n=(newnpnts)/O $(nameofwave(inputwave)+"_rebin") = 0	WAVE rebinnedwave = $(nameofwave(inputwave)+"_rebin")		// offset the new wave by half a reductionfactor to make it align better	setscale/p x, xoffset + 0.5*(xdelta*reductionfactor),xdelta*reductionfactor,rebinnedwave	// for each point in the new wave 	for (i=0; i < newnpnts; i += 1)		//printf "\r\rpoint %d in new wave\r", i		// index into the input wave using reductionfactor as a multiplier and then sum up reductionfactor number of points		// point 0 is sum of 0-4		// point 1 is sum of 5-9		// point 2 is sum of 10-14		for (j=0; j < reductionfactor; j += 1)						//printf "+ %d\r", inputwave[i*reductionfactor + j]			rebinnedwave[i] += inputwave[i*reductionfactor+j]					endfor	endfor		// originally developed this code for smoothing periodograms, in which case this line is not too harmful	//  for other types of histograms don't use this	//rebinnedwave /= reductionfactorend// returns 1 if value is present in searchwave// note: recasts searchwave as integer waveFunction IsIntegerPresent (value, searchwave)	variable value	wave searchwave		redimension/I searchwave	variable length = numpnts(searchwave),i		for (i=0; i < length; i += 1)			if (searchwave[i] == value)			return 1		endif		endfor		return 0	end		Function deletesmalltail (thewave)	wave thewave		variable length = numpnts(thewave), i		// go through the wave and if the difference between a point and the point before it is small, delete the rest of the points	for (i=50; i < length; i += 1)			if ((abs(thewave[i] - thewave[i-1]) < 0.0000000001)) //&& (abs(thewave[i]) < 0.000001))			//print i			deletepoints/m=0 (i-1), (length-i+1),thewave		endif			endforendFunction fixto4ms (thewave)	wave thewave		variable timeres = dimdelta(thewave,0)	variable reductionfactor		if (timeres != 4)				reductionfactor = round(4/timeres)		//myresample(thewave,reductionfactor)		endif	end// this function will take a data set number and look for that number//	in waves in the root directory which begin with prefix.//	it will return the part of the found wave name which follows prefix.  this serves as //	an experimentID.//	practical use of this is to search through waves named trials_XXX, find the movienumber, and //	return the XXX for lookup of other experiment parameters like cellmask_XXX, etc.//	NOTE: this function will warn and abort if it finds more than oneFunction/S getMyExptID (datanumber, prefix)	variable datanumber	string prefix	string currentDF = getdatafolder(1)	setdatafolder root:	string nextwavename, prefixwaves = wavelist(prefix+"*",";",""), theAnswer	variable numwaves = itemsinlist(prefixwaves), i, numhits = 0	for (i=0; i < numwaves; i += 1)			nextwavename = stringfromlist(i,prefixwaves)						findvalue/i=(datanumber) $nextwavename		if (V_Value >= 0)					printf "found number %d in %s\r", datanumber, nextwavename			theAnswer = nextwavename[strlen(prefix), strlen(nextwavename)-1]			numhits += 1					endif		endfor		// after going through all prefix* waves in root		if (numhits == 0)		printf "aborting at getMyExptID for %d; number not found in any wave matching %s\r", datanumber, prefix		setdatafolder $currentDF		abort	elseif (numhits > 1)		printf "aborting at getMyExptID for %d; number found in multiple trial lists in root", datanumber		setdatafolder $currentDF		abort	endif		setdatafolder $currentDF		return theAnswerendFunction zeroandintegrate (theWave, start, delta)	Wave theWave	Variable start, delta		duplicate/o/R=(start, start+delta) theWave, dummy	variable baseline = dummy(start)	dummy -= baseline	integrate dummy		return dummy[numpnts(dummy)-1]		//killwaves dummyend // recursive algorithm for traversing a tree   // traverse the whole datafolder structure below startfolder, // executing the specified command on all waves matching matchstringFunction TraverseAndExecute(startfolder, command, matchstring)	string startfolder, command, matchstring			// recursively traverse the whole shebang starting at datafolder		setdatafolder $startfolder	//print getdatafolder(0)	executecmdonlist(command, wavelist(matchstring,"",""))	// list data folders	string folders = folderlist("*",";","")	variable numfolders = itemsinlist(folders),i		for (i = 0; i < numfolders; i += 1)				TraverseAndExecute(stringfromlist(i,folders), command, matchstring)	endfor		// we will get to here either by having 0 folders in a df (in which case for loop will be skipped)	// or by iterating through all of them		// root is a special case		if (!stringmatch(startfolder, "root:"))		setdatafolder ::	endif		return 1end		// movielist is an integer wave at the root level containing a list of numbers// directory names built from prefix + movielist elements// command is executed in each data directoryFunction DoOnMovieBatch (prefix, movielist, command)	String prefix	WAVE movielist	string command		string directoryname	variable numtimes = numpnts(movielist),i	for (i=0; i < numtimes; i += 1)				setdatafolder root:		directoryname = prefix + num2str(movielist[i])		setdatafolder $directoryname		print getdatafolder(0)		execute command 	endfor	setdatafolder root:	end// circularly shift a wave// shift specified in points (for now)Function circshift (wavetoshift, shift)	wave wavetoshift	variable shift			duplicate/o wavetoshift temp	variable numpoints = numpnts(wavetoshift)		wavetoshift = (p -shift >= 0) ? (temp[p-shift]) : temp[numpoints-(shift-p)]endFunction breakcolumnwave (theWave) 	WAVE theWave	variable length = numpnts(theWave),i		for (i = 0; i < (length/2); i += 1)			make/n=2/O $("break" +num2str(i))		WAVE breakwave = $("break" +num2str(i))		breakwave[0] = theWave[i*2]		breakwave[1] = theWave[i*2 + 1]	endfor	end//returns the closest integer to valueFunction closestinteger (value)	variable value		variable floordiff = value - floor(value)	variable ceildiff = ceil(value) - value		if (ceildiff >= floordiff)				return floor(value)	else		return ceil(value)	endifend//Function maketrialgroup([rangestring, suffix])	String rangestring,suffix	if (ParamIsDefault(rangestring))		Prompt rangestring, "comma-separated list of files and ranges"		Prompt suffix, "identifier for list wave name"		DoPrompt "Enter info for trial group", rangestring, suffix		if (V_flag)			abort		endif	endif		setdatafolder root:	parseliststring(rangestring)	WAVE numberlist	duplicate/o numberlist $("trials_"+suffix)	killwaves numberlist	end// written by Rick Gerkin// http://www.igorexchange.com/node/1032Function /S FindTrace(trace_to_find)	String trace_to_find	String wins=WinList("*",";","WIN:1")	Variable i,j; String win,traces,trace	for(i=0;i<ItemsInList(wins);i+=1)		win=StringFromList(i,wins)		traces=TraceNameList(win,";",3)		for(j=0;j<ItemsInList(wins);j+=1)			trace=StringFromList(j,traces)			if(StringMatch(trace,trace_to_find))				return win			endif		endfor		endfor	return ""EndFunction deleteduplicatevalues (theWave)	WAVE theWave		sort thewave, thewave		duplicate/O theWave forwardderiv, backwardderiv	duplicate/O theWave oldwave		differentiate/meth=1 forwardderiv		FindLevels/Q/P forwardderiv, 1	WAVE W_FindLevels		redimension/n=(V_LevelsFound+1) theWave	variable i	// for the first one take the one with it and the next one	theWave[0] = oldwave[W_FindLevels[0]]	theWave[1] = oldwave[W_FindLevels[0]+1]			for (i=2; i < (V_levelsfound+1); i += 1)				// for all others take the next one		theWave[i] = oldwave[W_FindLevels[1]+1]	endfor	killwaves forwardderiv, backwardderiv, oldwave	endFunction getnextfreemvnumber ()	setdatafolder root:	variable i	for (i=0; i<1000; i+=1)				if (!DataFolderExists("mv"+num2str(i)))			return i		endif	endfor	end// scan myDataPaths and create actual Igor paths from any of them that existFunction PathTextWaveToPaths (pathtextwave)	WAVE/T pathtextwave		String nextPotentialPath, nextPotentialPathName	setdatafolder root:	if (WaveExists(myDatapaths))		WAVE/T myDatapaths		variable numPotentialPaths = dimsize(myDatapaths,0),i		for (i=0; i < numPotentialPaths; i += 1)			nextPotentialPath = removeending(myDatapaths[i][1], ":")			nextPotentialPathName = myDatapaths[i][0]				// test if folder exists			GetFileFolderInfo/Q/Z nextPotentialPath						// if it does, create the path			if(!V_Flag && V_isFolder )				NewPath/o $nextPotentialPathName, myDatapaths[i][1]			endif		endfor				endif	endFunction breakupmatrix (matrix, byplaterows, IDstring)	variable byplaterows	string IDstring	wave matrix		variable height = DimSize(matrix, 0)	variable width = DimSize(matrix, 1),i	variable numnewwaves, newwavesize	if (byplaterows)		numnewwaves = width		newwavesize = height	else		numnewwaves = height		newwavesize = width	endif		for (i=0; i < numnewwaves; i += 1)		make/n=(newwavesize)/o $(nameofwave(matrix)+IDstring+num2str(i+1))/WAVE=nextwave			if (byplaterows)				nextwave = matrix[p][i]		else			nextwave = matrix[i][p]		endif			endforend// print out average and SD of two valuesFunction quickavgSD(value1,value2, avgorSD)	variable value1, value2,avgorSD		variable average = (value1+value2)/2		variable SD = sqrt((value1-average)^2 + (value2-average)^2)		printf "avg = %f\rSD = %f\r", average, SD		if (avgorSD)		return average	else		return SD	endifend// filterALL// bandpass filter all waves in folder between LOWCUT and HIGHCUT// overwrites waves if suffix = ""Function filterALL (LOWCUT, HIGHCUT, [suffix])	Variable LOWCUT, HIGHCUT	string suffix		string wavenames = wavelist("*",";",""),nextwavename	variable numwaves = itemsinlist(wavenames),i		for (i=0; i < numwaves; i += 1)			nextwavename = (StringFromList(i,wavenames))			FilterF1(nextwavename, LOWCUT,HIGHCUT, suffix=suffix)		printf "filtered %s with cutoffs %d and %d\r", nextwavename, LOWCUT, HIGHCUT		redimension/W $nextwavename		printf "also redimensioned back to integer\r"					endfor	end//**************************// Produces a filtered version of srcwve with name srcwve+"f" with low and high-pass// frequencies low & high (Hz). If no low or high required enter 0.  // NB: requires that input movie x units be "ms"!!// this came from WaveCalc, which came from a guy at Laval via Diego Contreras// subsequently annotated by Gene Civillico 2004// 2012 - trying to remove an extra duplicateFunction FilterF1(srcwve, low,high, [suffix])	String srcwve,suffix	Variable low,high			String trgwve	Variable np, npfft		Variable filtorder=6		wave src = $srcwve		// for some reason Nicolet waves always start with Nan	if (numtype(src[0]) == 2)		src[0] = src[1]	endif	wavestats/q $srcwve	if (V_numNans != 0)		nanscan(src)	endif			np=numpnts(src)		// source wave points	Variable originaloffset=dimoffset(src,0)	Variable originaldelta=dimdelta(src,0)		if ((low!= 0)||(high != 0))			// is there filtering?		// assumes x-scaling of input is in terms of ms		// this line converts x-scaling to seconds (so FFT ends up in the same units as the input frequency bands)		SetScale/P x 0,(0.001 * originaldelta),"s", src		// CeilPwr2 returns the next-biggest power of 2 above the number of points in the wave		npfft = CeilPwr2(np)			// FFT		//printf "doing FFT\r"				try			// FFT is fastest if number of data points is a power of 2			FFT/PAD={npfft}/DEST=FFTresult src; abortonRTE;		catch			printf "run-time error while filtering %s\r aborting...", srcwve			abort		endtry				// now FFTresult is complex and has half as many points				// each point represents a frequency and there are half the sample number because you can only see frequencies up to 1/2 the sampling rate		// imagine you have a 1000-point wave; according to Nyquist there are 500 frequencies that you can measure and there will be a point for each one				// this line makes three waves which are the length of the FFT result			Make /O/N=(1+npfft/2) temp, wvereal,wveimag				// this line copies all data scaling from the FFTresult to these newly created waves		CopyScales/P FFTresult, temp, wvereal, wveimag						//  these conditions make a wave which drops from 1 to 0 at the appropriate frequency.  shape of the dropoff ("order" of the filter)		//	is determined by filtorder variable (default is 6)				if((low!= 0)&&(high != 0))			// bandpass filtering						temp = 1/(((1+(low/x)^filtorder)*(1+(x/high)^filtorder))^0.5)		else			if (low != 0)						//highpass filtering							temp = 1/(1+(low/x)^filtorder)^0.5				temp[0] = 0						elseif (high != 0)					// lowpass filtering											temp =1/(1+(x/high)^filtorder)^0.5						endif		endif				// set each point of wvereal and wveimag to the product of the corresponding point of the kernel and the corresponding point of the source		// why does this work?  temp, wvereal, and wveimag have half as many points as the source		wvereal=temp*real(FFTresult)		wveimag=temp*imag(FFTresult)				FFTresult = cmplx(wvereal,wveimag)				Killwaves /Z wvereal,wveimag, temp		//printf "doing inverse FFT\r"				IFFT /Z FFTresult				// "de-pad" the wave				deletepoints/m=0 np,npfft-np, FFTresult		SetScale/P x,originaloffset,originaldelta,"ms",  FFTresult			endif		if (paramisdefault(suffix))		// no suffix specified		duplicate/o FFTresult $(srcwve+"f")		// original wave still exists		// so restore its scaling		SetScale/P x 0,(originaldelta),"ms", src	else		duplicate/o FFTresult $(srcwve+suffix)		// original wave still exists, unless suffix is ""		// so test if "" and if not, restore its scaling		if (cmpstr(suffix,""))			SetScale/P x 0,(originaldelta),"ms", src		endif	endif		killwaves FFTresultend//--------------------------------------------------------// clears all data folders in current experiment, along with waves and variables (except those directly in root)// from Chris Hempelfunction clearDataFolders()string folders = datafolderdir(1)string thisFoldervariable i,n n= itemsInList(folders,",")closeAll()do	thisFolder = stringFromList(i,folders,",")	if(i==0)		thisFolder = thisFolder[8,strlen(thisFolder)]	endif	if(i==(n-1))		thisFolder = thisFolder[0,(strlen(thisFolder)-3)]	endif	killDataFolder $thisFolder	//killvariables /A /Z	//killstrings/A /Z	i+=1while (i<n)End//----------------------------------------------------// closes all graphs, tables, layouts, notebooks, panels and XOP target windows// from Chris Hempelfunction closeAll()	string windowName	do		windowName=WinName(0,1)		if (cmpstr(windowName, "")==0)			break		endif		doWindow /K $windowName	while (1)	do		windowName=WinName(0,2)		if (cmpstr(windowName, "")==0)			break		endif		doWindow /K $windowName	while (1)	do		windowName=WinName(0,4)		if (cmpstr(windowName, "")==0)			break		endif		doWindow /K $windowName	while (1)	do		windowName=WinName(0,16)		if (cmpstr(windowName, "")==0)			break		endif		doWindow /K $windowName	while (1)	do		windowName=WinName(0,64)		if (cmpstr(windowName, "")==0)			break		endif		doWindow /K $windowName	while (1)	do		windowName=WinName(0,4096)		if (cmpstr(windowName, "")==0)			break		endif		doWindow /K $windowName	while (1)end// iterate through all waves in a folder// print their names and the number of seconds since the last wave was createdFunction wavereport ()	String allwaves = Wavelist("*Input0",";","")	variable numwaves = itemsinlist(allwaves), i		printf "first wave is %s\r\r", StringFromList(0, allwaves)	variable previousdate = creationdate($StringFromList(0, allwaves)), thisdate,datedifference			for (i=1; i< numwaves; i += 1)			thisdate = creationdate($stringfromlist(i, allwaves))				datedifference = thisdate - previousdate				if (datedifference > 20)			printf "\r\r\r"		endif				printf "after %d seconds: %s\r",  datedifference, stringfromlist(i,allwaves)				previousdate = thisdate	endfor	endFunction statfill ()	WAVE capeaks, recnumber	variable i		for (i=0; i < numpnts(recnumber); i += 1)			WAVE next = $("::traces:mv"+num2str(recnumber[i])+"cellANDgrid")		Wavestats/R=(1000,2000)/Q next		Capeaks[i] = V_max	endforendFunction alldirectoriesexist(startindex, stopindex, S_path, mousefolder, experimentnames)	variable startindex,stopindex	string S_path, mousefolder	WAVE/T experimentnames		variable i	string nextpathdir		variable allexist = 1		for (i=startindex; i <=stopindex; i += 1)			nextpathdir = S_path + mousefolder + ":" + experimentnames[i]		newpath/Q/O/Z nextpath, nextpathdir		if (V_flag)			printf "%s not found in %s\r", experimentnames[i], S_path + mousefolder			allexist = 0		else			killpath nextpath		endif			endfor		return allexist	end// send in desired percentile as e.g. 85, 50Function pctile (values, histogramresolution, pct)	WAVE values	Variable pct, histogramresolution		wavestats/q values		// histogram the values	make/n=1/o values_hist	histogram/B={0, histogramresolution, (V_max/histogramresolution)+1} values values_hist	// accumulate the histogram	WAVE cumhist = $(cumhistfromregularhist(values_hist))		Wavestats/q cumhist	// return the value		FindLevel/Q cumhist, V_max*(pct/100)	return V_levelX		endFunction/S cumhistfromregularhist (regularhist)	WAVE regularhist		duplicate/o regularhist $(replacestring("_hist",nameofwave(regularhist),"_cumhist"))	string cumhistname = (replacestring("_hist",nameofwave(regularhist),"_cumhist"))	WAVE cumhist =  $cumhistname	cumhist = sum(regularhist,-inf,pnt2x(regularhist,p))		return cumhistname	end// "XXX" in nametemplate will be replaced with col numberFunction getcolsaswaves (wave2d, colswave, nametemplate)	WAVE wave2d, colswave	string nametemplate		variable num2get = numpnts(colswave),i	for (i=0; i < num2get; i += 1)		imagetransform/g=(colswave[i]) getcol wave2d		WAVE W_extractedcol				duplicate/o W_extractedcol $(replacestring("XXX",nametemplate,num2str(colswave[i])))	endforend// find all matching the two templates and divide them by each other to get a thirdFunction dividematchers (numeratortemplate, denominatortemplate, resulttemplate, start, stop, increment)	string numeratortemplate, denominatortemplate, resulttemplate	variable start, stop, increment		variable i, length		for (i=start; i <= stop; i += increment)			WAVE nextnumerator = $(numeratortemplate+num2str(i))		WAVE nextdenominator = $(denominatortemplate+num2str(i))		length = numpnts(nextnumerator)				make/O/N=(length) $(resulttemplate+num2str(i)) /WAVE=nextresult				nextresult = nextnumerator/nextdenominator								WAVE nextnumerator = $("")		WAVE nextdenominator = $("")		WAVE nextresult = $("")	endfor	endFunction removeifnotmarker (markernumber)	variable markernumber				string tracenames = TraceNameList("", ";", 1 ), nexttracename	variable numtraces = itemsinlist(tracenames), i, nextmarker		for (i=0; i < numtraces; i+= 1)			nexttracename = stringfromlist(i,tracenames)		nextmarker	= GetNumFromModifyStr(TraceInfo("",nexttracename,0),"marker","",0)		if (nextmarker != markernumber)					RemoveFromGraph $nexttracename			endif		endfor	endFunction/S cleanstring (inputstring)	String inputstring	string outputstring = ""	variable inputstringlength = strlen(inputstring),i	make/O/n=(inputstringlength) charIsallowed	for (i=0; i < inputstringlength; i += 1)			// is this an allowed character		charIsallowed[i] = CharAllowed(inputstring[i])	endfor	for (i=0; i < inputstringlength; i += 1)			if (charisallowed[i])			outputstring = outputstring + inputstring[i]		endif		endfor	killwaves charIsallowed	return outputstringendFunction CharAllowed(inputstring)	String inputstring	Variable inputstringasnum = char2num(inputstring)	// allowed characters are letters, numbers, and underscore	//48-57, 65-90, 95, 97-122	// is it a number?	if ((inputstringasnum >= 48) && (inputstringasnum <= 57))		return 1	endif	// is it a capital letter?	if ((inputstringasnum >= 65) && (inputstringasnum <= 90))		return 1	endif		// is it a lowercase letter?	if ((inputstringasnum >= 97) && (inputstringasnum <= 122))		return 1	endif	// is it an underscore?	if (inputstringasnum == 95)		return 1	endif	return 0 end// kill the waves in listFunction killwavelist (list)	string list		variable numwaves = itemsinlist(list),i	for (i=0; i < numwaves; i+=1)		WAVE nextwave = $(StringFromList(i, list))		killwaves/z nextwave		WAVE nextwave = $("")		endforend